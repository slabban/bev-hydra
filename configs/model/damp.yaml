
_target_: src.models.damp.Damp

# compile model for faster training with pytorch 2.0
compile: false
receptive_field: 3  # how many frames of temporal context (1 for single timeframe)
bn_momentum: 0.1

semantic_seg_weights: [1.0, 2.0]
semantic_seg_use_top_k: True
semantic_seg_top_k_ratio: 0.25


encoder:
  _target_: src.models.components.encoder.Encoder
  _partial_: true
  out_channels: 64
  use_depth_distribution: true
  downsample: 8
  name: efficientnet-b0


lift:
  # image to BEV lifting parameters
  # [min, max, step]
  x_bound: [-50.0, 50.0, 0.5] #Â Forward
  y_bound: [-50.0, 50.0, 0.5] # Sides
  z_bound: [-10.0, 10.0, 20.0] # Height
  d_bound: [2.0, 50.0, 1.0]

image:
  final_dim: [224, 480]
  resize_scale: 0.3
  top_crop: 46
  original_height: 900
  original_width: 1600
  names: [CAM_FRONT_LEFT, CAM_FRONT, CAM_FRONT_RIGHT, CAM_BACK_LEFT, CAM_BACK, CAM_BACK_RIGHT]

temporal_model:
  name: 'temporal_block'  # type of temporal model
  start_out_channels: 64
  extra_in_channels: 0
  inbetween_layers: 0
  pyramid_pooling: true
  input_egopose: true


# general configuration
# _C = CN()
# _C.LOG_DIR = 'tensorboard_logs'
# _C.TAG = 'default'

# _C.GPUS = [0]  # gpus to use
# _C.PRECISION = 32  # 16bit or 32bit


# pretrained model
# _C.PRETRAINED = CN()
# _C.PRETRAINED.LOAD_WEIGHTS = False
# _C.PRETRAINED.PATH = ''

# # semantic segmentation
# _C.SEMANTIC_SEG = CN()
# _C.SEMANTIC_SEG.WEIGHTS = [1.0, 2.0]  # per class cross entropy weights (bg, dynamic)
# _C.SEMANTIC_SEG.USE_TOP_K = True  # backprop only top-k hardest pixels
# _C.SEMANTIC_SEG.TOP_K_RATIO = 0.25

# instance segmentation
# _C.INSTANCE_SEG = CN()
# _C.INSTANCE_FLOW = CN()
# _C.INSTANCE_FLOW.ENABLED = True


# _C.OPTIMIZER = CN()
# _C.OPTIMIZER.LR = 3e-4
# _C.OPTIMIZER.WEIGHT_DECAY = 1e-7
# _C.GRAD_NORM_CLIP = 5

